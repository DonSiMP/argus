# odoflow
Package for planar (ground-facing) visual **odo**metry using optical **flow**. Contains software for both sparse and dense visual odometry.

# Dependencies
* OpenCV 3+
* [argus_utils](https://github.com/Humhu/argus_utils): Utilities for all argus packages

# Design Concepts
## Keyframing
Both odoflow nodes align received images to *keyframes* until some failure mode is reached. This minimizes drift when there is little motion and also reduces bias resulting from loose solver tolerances.

## Velocity Prediction
The image alignment algorithms are seeded with displacement predictions generated by integrating an odometry topic. Typically this is expected to be output by a state estimator. This is a more general form of IMU priors found in other work, as the odometry topic filter can fuse information from any number of sources. If the same filter also fuses the output of the visual odometry node, this theoretically results in bias, but is often perfectly fine in practice.

# Nodes
## dense_vo_node
Performs dense image alignment of frames to keyframes to estimate the camera velocity. For more details, refer to the [OpenCV documentation](https://docs.opencv.org/3.0-alpha/modules/video/doc/motion_analysis_and_object_tracking.html#findtransformecc).

### Subscriptions
* `image`: A `sensor_msgs/Image` topic to perform alignment on

### Publications
* `~velocity_raw`: A `geometry_msgs/TwistStamped` topic of the estimated camera velocity for each frame
* `image_debug`: A `sensor_msgs/Image` topic displaying the alignment if `~debug` is true.

### Parameters
#### General
* `~scale`: (float) The scale factor to multiply linear (pixel) velocities by to convert to meters per second
* `~debug`: (bool, default false) Whether or not to output debug images
* `~enable_prediction`: (bool, default false) Whether or not to enable velocity prediction
* `~prediction_mode`: ('odometry' or 'twist_stamped') The prediction

#### Algorithm
* `~pyramid_depth`: (unsigned int, default 0) The number of pyramid levels to use. 0 means no pyramiding.
* `~max_displacement`: (float, default 0.2) Max allowable keyframe displacement as ratio of image width before getting new keyframe. Should be between 0.0 and 1.0.
* `~max_predict_entropy`: (float, default 1.0) The max allowable integrated displacement entropy before resorting to the zero displacement prior
* `~min_time_delta`: (float, default 0.0) Min time in seconds between frames before velocity will be estimated
* `~min_pixel_variance`: (float, default 10.0) Min required variance across an image pixel values (0-255) to be used
* `~log_min_eps`: (float, default -3) Base 10 log solver tolerance epsilon
* `~max_iters`: (unsigned int, default 50) Max allowable number of algorithm iterations
* `~log_min_correlation`: (float, default -2) 1.0 - Base 10 of min required alignment correlation for good alignment. For example, default value corresponds to 0.99 correlation.

#### Visualization
* `~vis_arrow_scale`: (float, default 1.0) The scale factor to multiply the pixel velocities by for debug visualization
